<!DOCTYPE html>
<html lang="en"><head><title>Setting Shadows Recursively in Unity GameObjects | Blog</title><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="description" content="Reese's website about programming."><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="alternate" type="application/rss+json" title="Reese Schultz" href="../../feed.json"><link rel="icon" type="image/x-icon" href="../../../favicon.ico"><link rel="stylesheet" href="../../../styles.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/base16/dracula.min.css"><meta property="og:type" content="website">
<meta property="og:site_name" content="Reese Schultz">
<meta property="og:locale" content="en">
<meta property="og:description" content="Reese's website about programming.">
<meta property="og:url" content="http://localhost/blog/post/setting-shadows-recursively-in-unity-gameobjects/">
<meta name="twitter:description" content="Reese's website about programming.">
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@ReeseCodes">
<meta itemprop="description" content="Reese's website about programming.">
<meta name="description" content="Reese's website about programming.">
<meta name="generator" content="Lume v1.10.1">
</head><body><div id="header"><h1><a href="../../..">Reese<br>Schultz</a></h1></div><p class="go-back for-post"><a class="change-color" href="../..">...back to the blog!</a></p><div id="content"><div id="post"><h2>Setting Shadows Recursively in Unity GameObjects</h2><p>Want to turn shadows on and off for a GameObject and all its children? I'll show you how.</p><div class="for-post" id="post-info"><ul class="tags for-post"><li class="tag unity"><a href="../../tag/unity">unity</a></li><li class="tag csharp"><a href="../../tag/csharp">c#</a></li></ul><p class="date for-post">Last updated on August 31, 2021.</p><p class="date for-post">Created on August 28, 2021.</p></div><p>I wrote an extension method for recursively toggling shadows. You're free to use
it! It's relatively straightforward:</p>
<pre><code class="language-csharp">public static void SetShadowsRecursively(this GameObject gameObject, ShadowCastingMode mode, bool includeInactive = false)
{
    if (gameObject == null) return;

    var renderers = gameObject.GetComponentsInChildren&lt;Renderer&gt;(includeInactive);

    if (renderers == null) return;

    foreach (var renderer in renderers) renderer.shadowCastingMode = mode;
}
</code></pre>
<h3>Usage</h3>
<p>Copy and paste that code in some utility class. To use it, you can do something
like the following:</p>
<pre><code class="language-csharp">var parentGameObject = GameObject.CreatePrimitive(PrimitiveType.Sphere);

var childGameObject = GameObject.CreatePrimitive(PrimitiveType.Cube);
childGameObject.transform.parent = parentGameObject.transform;
childGameObject.transform.localPosition = new Vector3(3, 0, 3);

parentGameObject.SetShadowsRecursively(ShadowCastingMode.Off); // No more shadows!
</code></pre>
<h3>Explanation</h3>
<p>Recall that <code>SetShadowsRecursively</code> is an <em>extension method</em>. This is a special
type of method that extends an existing class. If you find its first parameter
confusing, check out my
<a href="../how-extension-methods-work-in-csharp" target="_blank">tutorial on extension methods</a>.</p>
<p>The second parameter is of the type <code>ShadowCastingMode</code>, which comes from
<code>UnityEngine.Rendering</code> (make sure you import it!). Remember that this is the
parameter:</p>
<pre><code class="language-csharp">ShadowCastingMode mode
</code></pre>
<p>It's an <code>enum</code> that can be one of four possible values:</p>
<ul>
<li><code>Off</code> - Disables shadows.</li>
<li><code>On</code> - Enables shadows projected outside the object's normals.</li>
<li><code>TwoSided</code> - Enables shadows projected inside and outside the object's normals
(you should normally prefer <code>On</code> instead).</li>
<li><code>ShadowsOnly</code> - Makes the object invisible, but its shadows are visible.</li>
</ul>
<p>The third and final parameter, <code>includeInactive</code>, is <em>optional</em>. It's false by
default, indicated by the equals sign followed by <code>false</code> like so:</p>
<pre><code class="language-csharp">bool includeInactive = false
</code></pre>
<p><code>includeInactive</code> means to include inactive GameObjects. For example, if you
have an object pool of inactive GameObjects whose shadow modes you want to
recursively set, this is a necessary parameter. There are other use cases as
well.</p>
<p>Moving on, we need to check if the GameObject is null like so:</p>
<pre><code class="language-csharp">if (gameObject == null) return;
</code></pre>
<p>Returning from a void function in this way is called an <em>early out</em>. I love
early outs, and so should you. Using them whenever possible to exit a function
keeps your code readable and maintainable.</p>
<p>Next, we get all the renderers recursively with this line:</p>
<pre><code class="language-csharp">var renderers = gameObject.GetComponentsInChildren&lt;Renderer&gt;(includeInactive);
</code></pre>
<p>The <code>var</code> keyword is a convenience of compile-time type inference. We know
<code>renderers</code> is of the type <code>Renderer[]</code>, as in an array of renderers, because
that is what <code>GetComponentsInChildren</code> is guaranteed to return.</p>
<p>You should know that the name <code>GetComponentsInChildren</code> may be a bit of a
misdirect, because it includes components in the parent(!) as well as immediate
children, and their children(!), and so on.</p>
<p>You may also be wondering why I chose to get components of type <code>Renderer</code>
instead of <code>MeshRenderer</code>. This way it works generically—in addition to
GameObjects with the <code>MeshRenderer</code>, the method will apply for those with
<code>LineRenderer</code>, and other inheritors of <code>Renderer</code>. (Feel free to modify the
method to only affect only specific types.)</p>
<p>Moving on, there is a null check for <code>renderers</code>:</p>
<pre><code class="language-csharp">if (renderers == null) return;
</code></pre>
<p>Null <code>renderers</code> is possible in an exceptional case. Again, an early out is an
acceptable way to deal with this.</p>
<p>Finally, we opt for a single-line <code>foreach</code> block to set each <code>Renderer</code> to the
specified <code>mode</code>:</p>
<pre><code class="language-csharp">foreach (var renderer in renderers) renderer.shadowCastingMode = mode;
</code></pre>
<p>Many people detest single-line expressions, but I find them terse and elegant.
Still, change the function to match your sensibilities at your leisure.</p>
<h3>Conclusion</h3>
<p>Programmers new to C# may find extension methods and optional parameters jarring
at first, as did I, but I find them to be fantastically useful language
features. Also, Unity's APIs and naming conventions can understandably throw one
for a loop (no pun intended). I hope the extension method and/or tutorial helped
you!</p>
</div></div><ul class="social"><li class="github"><a target="_blank" href="https://github.com/reeseschultz"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 20 20"><title>Link to GitHub Profile</title><path d="M10 0a10 10 0 0 0-3.16 19.49c.5.1.68-.22.68-.48l-.01-1.7c-2.78.6-3.37-1.34-3.37-1.34-.46-1.16-1.11-1.47-1.11-1.47-.9-.62.07-.6.07-.6 1 .07 1.53 1.03 1.53 1.03.9 1.52 2.34 1.08 2.91.83.1-.65.35-1.09.63-1.34-2.22-.25-4.55-1.11-4.55-4.94 0-1.1.39-1.99 1.03-2.69a3.6 3.6 0 0 1 .1-2.64s.84-.27 2.75 1.02a9.58 9.58 0 0 1 5 0c1.91-1.3 2.75-1.02 2.75-1.02.55 1.37.2 2.4.1 2.64.64.7 1.03 1.6 1.03 2.69 0 3.84-2.34 4.68-4.57 4.93.36.31.68.92.68 1.85l-.01 2.75c0 .26.18.58.69.48A10 10 0 0 0 10 0"></path></svg></a></li><li class="youtube"><a target="_blank" href="https://www.youtube.com/channel/UC9DCrtoQBTBrIyZ4mXNzlTA"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 22"><title>Link to YouTube Channel</title><path d="M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z"></path></svg></a></li><li class="twitter"><a target="_blank" href="https://twitter.com/ReeseCodes"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 20 20"><title>Link to Twitter Profile</title><path d="M6.29 18.25c7.55 0 11.67-6.25 11.67-11.67v-.53c.8-.59 1.49-1.3 2.04-2.13-.75.33-1.54.55-2.36.65a4.12 4.12 0 0 0 1.8-2.27c-.8.48-1.68.81-2.6 1a4.1 4.1 0 0 0-7 3.74 11.65 11.65 0 0 1-8.45-4.3 4.1 4.1 0 0 0 1.27 5.49C2.01 8.2 1.37 8.03.8 7.7v.05a4.1 4.1 0 0 0 3.3 4.03 4.1 4.1 0 0 1-1.86.07 4.1 4.1 0 0 0 3.83 2.85A8.23 8.23 0 0 1 0 16.4a11.62 11.62 0 0 0 6.29 1.84"></path></svg></a></li></ul><div id="footer"><div id="copyright-and-license"><p id="copyright">© 2021-2022 <a href="../../..">Reese Schultz</a></p><a id="license" href="../../../license">License</a></div></div><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"></script><script>if (hljs) hljs.highlightAll();</script><script src="//cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.10/clipboard.min.js"></script><script src="../../../copy.js"></script></body></html>